# spice_gen

Automatic SPICE netlist generator from YAML/JSON cell topology descriptions.

Define your circuit once in a readable YAML file — `spice_gen` handles port ordering, parameter formatting, dialect-specific syntax, and PDK model name resolution for you.

## Features

- **YAML/JSON input** — describe cells with named, order-independent port connections
- **Correct port ordering** — MOSFET `D G S B`, BJT `C B E`, diode `A K`, etc. are enforced automatically
- **Primitive devices** — NMOS, PMOS, NPN, PNP, R, C, L, voltage/current sources, diode
- **Hierarchical subcircuits** — instantiate `.subckt` blocks; port order resolved from definition
- **Multiple output dialects** — `spice3`, `hspice`, `ngspice`
- **Hierarchical cell composition** — reference other cell YAMLs via `deps:`; port order, deduplication, and dependency ordering are resolved automatically
- **PDK-aware generation** — map logical device names to technology-specific model names via a PDK config YAML; includes `.lib` injection and automatic M→X element conversion for subcircuit-wrapped PDKs (e.g. sky130A)
- **Portable topologies** — the same cell YAML runs against any PDK by swapping the `--pdk` argument
- **CLI tool** — single command, stdout or file output

## Installation

Requires Python 3.10+.

```bash
pip install -e .
```

To include development dependencies (pytest):

```bash
pip install -e ".[dev]"
```

## Quick Start

```bash
# SPICE3 (default), no PDK
spice_gen examples/inverter.yaml --stdout

# HSPICE to file
spice_gen examples/nand2.yaml --dialect hspice --output nand2.sp

# ngspice, sky130A PDK, typical corner
spice_gen examples/sky130_inverter.yaml --pdk pdks/sky130A.yaml --dialect ngspice --stdout

# ngspice, sky130A PDK, fast-fast corner
spice_gen examples/sky130_inverter.yaml --pdk pdks/sky130A.yaml --corner ff --dialect ngspice --stdout
```

## Input Format

Topology files use a simple YAML (or JSON) schema:

```yaml
cell:
  name: INV
  ports: [A, Z, VDD, VSS]   # defines .subckt pin order
  components:
    - id: MP1
      type: primitive
      model: pmos            # nmos | pmos | npn | pnp | r | c | l | vsrc | isrc | diode
      connections:           # named dict — order does not matter
        D: Z
        G: A
        S: VDD
        B: VDD
      parameters:
        W: 2e-6
        L: 180e-9
        model_name: pch      # device model card reference (or logical name for PDK mode)

    - id: MN1
      type: primitive
      model: nmos
      connections: {D: Z, G: A, S: VSS, B: VSS}
      parameters: {W: 1e-6, L: 180e-9, model_name: nch}
```

Subcircuit instantiation:

```yaml
    - id: XBIAS
      type: subckt
      model: BIAS_GEN        # referenced .subckt name
      connections:
        VREF: vref_node
        VDD: VDD
        VSS: VSS
        IOUT: tail_net
```

### Hierarchical cell composition

Use `deps:` to declare that a cell's YAML depends on other cell YAMLs.  The
loader resolves them recursively, handles diamond dependencies (shared cell
emitted once), and detects cycles:

```yaml
cell:
  name: BUF
  ports: [A, Z, VDD, VSS]
  deps:
    - inv.yaml          # path relative to this file
  components:
    - id: XINV1
      type: subckt
      model: INV
      connections: {A: A, Z: mid, VDD: VDD, VSS: VSS}
    - id: XINV2
      type: subckt
      model: INV
      connections: {A: mid, Z: Z, VDD: VDD, VSS: VSS}
```

The generated netlist contains `.subckt INV` before `.subckt BUF`, and port
order for `XINV1`/`XINV2` is resolved automatically from `INV`'s definition.
See `examples/sky130_aoi21.yaml` for a three-level hierarchy example (AOI21
composed from NAND2 and INV).

### Supported primitive models

| `model` | SPICE letter | Port order |
|---------|-------------|------------|
| `nmos`, `pmos` | `M` | `D G S B` |
| `npn`, `pnp` | `Q` | `C B E` |
| `r` | `R` | `P N` + `value` |
| `c` | `C` | `P N` + `value` |
| `l` | `L` | `P N` + `value` |
| `vsrc` | `V` | `P N` + `value` |
| `isrc` | `I` | `P N` + `value` |
| `diode` | `D` | `A K` |

## PDK-Aware Generation

### How it works

Topology YAMLs use **logical model names** instead of raw PDK strings:

```yaml
parameters:
  model_name: nmos_1v8    # logical name — technology-agnostic
```

A PDK config file maps logical names to actual PDK model names and provides the `.lib` file path:

```yaml
# pdks/sky130A.yaml
name: sky130A
path: /usr/local/share/pdk/sky130A
lib_file: libs.tech/ngspice/sky130.lib.spice
corners: [tt, ff, ss, sf, fs]
default_corner: tt
models:
  nmos_1v8: {pdk_name: sky130_fd_pr__nfet_01v8, is_subckt: true, ports: [d, g, s, b]}
  pmos_1v8: {pdk_name: sky130_fd_pr__pfet_01v8, is_subckt: true, ports: [d, g, s, b]}
  ...
```

Pass `--pdk` at generation time:

```bash
spice_gen examples/sky130_inverter.yaml --pdk pdks/sky130A.yaml --dialect ngspice --stdout
```

Output:

```spice
* Generated by spice_gen  [ngspice]  cell=INV_SKY130
.lib "/usr/local/share/pdk/sky130A/libs.tech/ngspice/sky130.lib.spice" tt
.subckt INV_SKY130 A Z VDD VSS
XMP1 Z A VDD VDD sky130_fd_pr__pfet_01v8 W=1.0 L=0.15 nf=1
XMN1 Z A VSS VSS sky130_fd_pr__nfet_01v8 W=0.5 L=0.15 nf=1
.ends INV_SKY130
```

Note: sky130A transistors are subcircuit-wrapped in the PDK, so `M` elements are automatically converted to `X` elements (`is_subckt: true`). For PDKs that use native `.model` cards (e.g. TSMC), set `is_subckt: false` and `M` elements are kept with the model name replaced.

### PDK config schema

| Field | Description |
|-------|-------------|
| `name` | PDK identifier |
| `path` | Base path to the PDK installation |
| `lib_file` | Path to the `.lib` file, relative to `path` |
| `corners` | List of available process corners |
| `default_corner` | Corner used when `--corner` is not specified |
| `models` | `logical_name → {pdk_name, is_subckt, ports}` |

Each model entry:

| Field | Description |
|-------|-------------|
| `pdk_name` | Actual PDK model/subcircuit name |
| `is_subckt` | `true` → emit X element; `false` → keep native M/Q/D element |
| `ports` | PDK port order (e.g. `[d, g, s, b]`); omit to use canonical order |

### Multiple voltage devices

For PDKs with multiple voltage domains (e.g. TSMC 65nm with 1.2V core and 2.5V IO), define a separate logical name per variant:

```yaml
# pdks/tsmc65.yaml
models:
  nmos_1v2:  {pdk_name: nch,     is_subckt: false, ports: [d, g, s, b]}
  nmos_2v5:  {pdk_name: nch_25,  is_subckt: false, ports: [d, g, s, b]}
  pmos_1v2:  {pdk_name: pch,     is_subckt: false, ports: [d, g, s, b]}
  pmos_2v5:  {pdk_name: pch_25,  is_subckt: false, ports: [d, g, s, b]}
```

In the topology YAML, each device references its appropriate logical name — resolution is per-device and fully automatic.

### Unrecognised model names

If a `model_name` is not found in the PDK config it is passed through unchanged. This lets you mix PDK-resolved devices with explicit model names in the same topology file.

## Output Examples

**Inverter — SPICE3 (no PDK)**

```spice
* Generated by spice_gen  [spice3]  cell=INV
.subckt INV A Z VDD VSS
MMP1 Z A VDD VDD pch W=2e-6 L=180e-9
MMN1 Z A VSS VSS nch W=1e-6 L=180e-9
.ends INV
```

**NAND2 — HSPICE (no PDK)**

```spice
* Generated by spice_gen  [hspice]  cell=NAND2
.subckt NAND2 A B Z VDD VSS
MMP1 Z A VDD VDD pch PARAMS: W=2e-6 L=180e-9
MMP2 Z B VDD VDD pch PARAMS: W=2e-6 L=180e-9
MMN1 Z A mid VSS nch PARAMS: W=2e-6 L=180e-9
MMN2 mid B VSS VSS nch PARAMS: W=2e-6 L=180e-9
.ends NAND2
```

**sky130A inverter — ngspice**

```spice
* Generated by spice_gen  [ngspice]  cell=INV_SKY130
.lib "/usr/local/share/pdk/sky130A/libs.tech/ngspice/sky130.lib.spice" tt
.subckt INV_SKY130 A Z VDD VSS
XMP1 Z A VDD VDD sky130_fd_pr__pfet_01v8 W=1.0 L=0.15 nf=1
XMN1 Z A VSS VSS sky130_fd_pr__nfet_01v8 W=0.5 L=0.15 nf=1
.ends INV_SKY130
```

## CLI Reference

```
spice_gen <input> [-d DIALECT] [-o FILE] [--stdout] [--pdk PDK_YAML] [--corner CORNER] [-v]

positional arguments:
  input              Path to input .yaml, .yml, or .json file

options:
  -d, --dialect      Output dialect: spice3 | hspice | ngspice  (default: spice3)
  -o, --output       Output file path (default: <input_stem>_<dialect>.sp)
  --stdout           Write to stdout instead of a file
  --pdk PDK_YAML     Path to PDK config YAML for technology-aware generation
  --corner CORNER    Process corner (e.g. tt, ff, ss). Defaults to PDK's default_corner
  -v, --verbose      Print diagnostic info to stderr
```

## Project Structure

```
spice_gen/
├── pdks/
│   └── sky130A.yaml            # sky130A PDK config (16 device types)
├── examples/
│   ├── inverter.yaml           # generic inverter
│   ├── nand2.yaml              # generic NAND2
│   ├── opamp_snippet.yaml      # diff pair + passives
│   ├── sky130_inverter.yaml    # sky130A inverter (logical model names)
│   ├── sky130_nand2.yaml       # sky130A NAND2
│   └── sky130_aoi21.yaml       # sky130A AOI21 (deps: nand2 + inverter)
└── src/spice_gen/
    ├── model/
    │   ├── primitives.py       # port-order registry — single source of truth
    │   ├── component.py        # PrimitiveComponent, SubcktInstance
    │   └── netlist.py          # SubcktDef, Netlist, PdkInclude
    ├── schema/
    │   └── cell_schema.py      # Pydantic v2 input validation
    ├── parser/
    │   ├── loader.py           # YAML/JSON → Netlist (recursive dep loading)
    │   └── builder.py          # validated schema → internal model
    ├── pdk/
    │   ├── pdk_config.py       # Pydantic schema for PDK YAML
    │   └── resolver.py         # logical name resolution + .lib injection
    ├── generator/
    │   ├── base.py             # abstract SpiceGenerator
    │   ├── spice3.py
    │   ├── hspice.py
    │   └── ngspice.py
    └── cli.py
```

## Running Tests

```bash
pytest tests/ -v
```

74 tests covering unit (primitives, builder, generators, PDK config, resolver, hierarchical deps) and integration (full YAML-to-SPICE round-trips for all three dialects, with and without PDK, including multi-level hierarchy).

## Extending with a New PDK

Create a YAML file following the PDK config schema — no code changes required:

```yaml
name: my_pdk
path: /path/to/my_pdk
lib_file: models/tt.lib.spice
corners: [tt, ff, ss]
default_corner: tt
models:
  nmos_core: {pdk_name: NMOS_CORE, is_subckt: false, ports: [d, g, s, b]}
  pmos_core: {pdk_name: PMOS_CORE, is_subckt: false, ports: [d, g, s, b]}
```

## Extending with a New Dialect

Subclass `SpiceGenerator` and implement two methods:

```python
from spice_gen.generator.base import SpiceGenerator

class LtspiceGenerator(SpiceGenerator):
    DIALECT_NAME = "ltspice"

    def _format_subckt_params(self, params):
        return ""  # LTspice uses .param separately

    def _format_instance_params(self, params):
        return " ".join(f"{k}={v}" for k, v in params.items())
```

Then register it in `generator/__init__.py`:

```python
DIALECT_REGISTRY["ltspice"] = LtspiceGenerator
```
