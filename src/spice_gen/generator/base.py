from __future__ import annotations

import abc

from ..model.component import AnyComponent, PrimitiveComponent, SubcktInstance
from ..model.netlist import Netlist, PdkInclude, SubcktDef


class SpiceGenerator(abc.ABC):
    """
    Abstract base class for SPICE dialect generators.

    Subclasses implement _format_subckt_params and _format_instance_params
    to handle dialect-specific syntax differences. All structural logic lives here.
    """

    DIALECT_NAME: str = "base"

    # ------------------------------------------------------------------ #
    # Public entry point
    # ------------------------------------------------------------------ #

    def generate(self, netlist: Netlist) -> str:
        """Produce a complete SPICE netlist string from a Netlist object."""
        sections: list[str] = []

        sections.append(self._format_header(netlist))

        # Emit PDK .lib / .include directives first
        for pdk_inc in netlist.pdk_includes:
            sections.append(self._format_pdk_include(pdk_inc))

        # Emit cell-level .include directives
        if netlist.subckt_defs:
            for inc in netlist.subckt_defs[0].includes:
                sections.append(self._format_include(inc))

        # Emit all subckt blocks
        for defn in netlist.subckt_defs:
            sections.append(self._format_subckt(defn, netlist))

        return "\n".join(filter(None, sections)) + "\n"

    # ------------------------------------------------------------------ #
    # Header / includes
    # ------------------------------------------------------------------ #

    def _format_header(self, netlist: Netlist) -> str:
        top_name = netlist.top_cell or "netlist"
        return f"* Generated by spice_gen  [{self.DIALECT_NAME}]  cell={top_name}"

    def _format_include(self, path: str) -> str:
        return f'.include "{path}"'

    def _format_pdk_include(self, pdk_inc: PdkInclude) -> str:
        """Emit the PDK model library. Default: .lib syntax (ngspice/hspice)."""
        return f'.lib "{pdk_inc.lib_file}" {pdk_inc.corner}'

    # ------------------------------------------------------------------ #
    # Subcircuit block
    # ------------------------------------------------------------------ #

    def _format_subckt(self, defn: SubcktDef, netlist: Netlist) -> str:
        lines: list[str] = [
            self._format_subckt_header(defn),
            *[self._format_component(comp, netlist) for comp in defn.components],
            self._format_subckt_footer(defn),
        ]
        return "\n".join(lines)

    def _format_subckt_header(self, defn: SubcktDef) -> str:
        ports_str = " ".join(defn.ports)
        line = f".subckt {defn.name} {ports_str}"
        if defn.parameters:
            line += " " + self._format_subckt_params(defn.parameters)
        return line

    @abc.abstractmethod
    def _format_subckt_params(self, params: dict[str, str]) -> str:
        """Dialect-specific inline parameter syntax on the .subckt line."""

    def _format_subckt_footer(self, defn: SubcktDef) -> str:
        return f".ends {defn.name}"

    # ------------------------------------------------------------------ #
    # Component dispatch
    # ------------------------------------------------------------------ #

    def _format_component(self, comp: AnyComponent, netlist: Netlist) -> str:
        if isinstance(comp, PrimitiveComponent):
            return self._format_primitive(comp)
        if isinstance(comp, SubcktInstance):
            return self._format_subckt_instance(comp, netlist)
        raise TypeError(f"Unknown component type: {type(comp)}")

    # ------------------------------------------------------------------ #
    # Primitive element line
    # ------------------------------------------------------------------ #

    def _format_primitive(self, comp: PrimitiveComponent) -> str:
        """
        Builds a SPICE element line, e.g.:
          MM1 drain gate src bulk model_name W=1e-6 L=100e-9
          RR1 net_p net_n 10000
          VVsup VDD 0 1.8
        """
        letter = comp.spec.spice_letter
        # Prefix: letter + instance name (e.g. "MM1", "RR_load")
        name_field = f"{letter}{comp.instance_name}"

        nets_str = " ".join(comp.ordered_nets())
        parts = [name_field, nets_str]

        # Model name comes after nets for transistors/diodes
        if comp.model_name is not None:
            parts.append(comp.model_name)

        # Value comes after model (for passives/sources model_name is None)
        if comp.value is not None:
            parts.append(str(comp.value))

        # Remaining named parameters
        if comp.parameters:
            parts.append(self._format_instance_params(comp.parameters))

        return " ".join(parts)

    @abc.abstractmethod
    def _format_instance_params(self, params: dict[str, str]) -> str:
        """Dialect-specific parameter string for instance lines."""

    # ------------------------------------------------------------------ #
    # Subcircuit instance line
    # ------------------------------------------------------------------ #

    def _format_subckt_instance(self, comp: SubcktInstance, netlist: Netlist) -> str:
        """
        Builds an X-element line:
          X<name> <net1> ... <netN> <subckt_name> [params]

        Port order is resolved from the referenced SubcktDef when available.
        For external (library) subcircuits not in this Netlist, the user's
        port_map insertion order is used as-is.
        """
        defn = netlist.get_subckt(comp.subckt_name)
        if defn is not None:
            ordered_nets = comp.ordered_nets(defn.ports)
        else:
            # External subcircuit: preserve user-specified dict order
            ordered_nets = list(comp.port_map.values())

        nets_str = " ".join(ordered_nets)
        line = f"X{comp.instance_name} {nets_str} {comp.subckt_name}"

        if comp.parameters:
            line += " " + self._format_instance_params(comp.parameters)

        return line
